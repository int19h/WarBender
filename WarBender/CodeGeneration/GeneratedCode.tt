<#@ template language="VB" compilerOptions="/optionstrict- /optioninfer+ /optionexplicit+"
             debug="false" hostspecific="false" #>
<#@ output extension=".cs" #>

<#@ assembly name="System" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Runtime" #>
<#@ assembly name="System.Text.Encoding" #>
<#@ assembly name="System.Threading.Tasks" #>
<#@ assembly name="$(MSBuildToolsPath)\Roslyn\Microsoft.CodeAnalysis.dll" #>
<#@ assembly name="$(MSBuildToolsPath)\Roslyn\Microsoft.CodeAnalysis.CSharp.dll" #>
<#@ assembly name="$(TargetPath)" #>

<#@ import namespace="System.CodeDom" #>
<#@ import namespace="System.CodeDom.Compiler" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="Microsoft.CodeAnalysis" #>  
<#@ import namespace="Microsoft.CodeAnalysis.CSharp" #>  
<#@ import namespace="Microsoft.CodeAnalysis.CSharp.Syntax" #>  
<#@ import namespace="WarBender" #>
<#@ import namespace="WarBender.CodeGeneration" #>

// This file is automatically generated from GeneratedCode.tt. Do not modify it directly!
// If you get build errors in this file, delete its entire contents and rebuild.

#pragma warning disable 162
#pragma warning disable 219

using System.CodeDom.Compiler;
using System.IO;

<#
Dim recordTypes = New RecordTypes
For Each kv In recordTypes
    Dim typeName = kv.Key
    Dim props = kv.Value
    Dim dot = typeName.LastIndexOf(".")
    Dim typeNamespace = typeName.Substring(0, dot)
    Dim shortTypeName = typeName.Substring(dot + 1)
    #>
  
    namespace <#= typeNamespace #> {
        [GeneratedCode("", "")]
        partial class <#= shortTypeName #> {
            public static <#= typeName #> Create() => new _Impl();

            private class _Impl : <#= typeName #> {
                <#@ include file="ReadFields.tt" #>

                <#@ include file="WriteFields.tt" #>

                <#
                For Each prop In props
                    If prop.NotifyPropertyChanged Then
                        #>
                        <#@ include file="Property.tt" #>
                        <#
                    End If
                Next
                #>

                public _Impl() {
                <#
                For Each prop In props
                    If prop.IsDataObjectChild Then
                        If Not prop.IsReadOnly Then
                            #>
                            <#= prop.Name #> = default;
                            <#
                        Else
                            #>
                            (<#= prop.Name #> as IDataObjectChild)?.WithParent(this, -1);
                            <#
                        End If
                        #>
                        <#
                    End If
                Next
                #>
                }
            }
        }
    }

    namespace WarBender {
        <#@ include file="DataObjectFactory.tt" #>
    }

<# 
Next
#> 

namespace WarBender {
    internal static partial class ValueSerializers {
        <#
        For Each kv In valueSerializers
            Dim serName = kv.Key
            Dim serValueType = CSharpTypeName(kv.Value)
            #> 
            [GeneratedCode("", "")]
            public static readonly IValueSerializer<<#= serValueType #>> <#= serName #> = ValueSerializer.Get<<#= serValueType #>>();
            <#
        Next
        #> 
    }

    <#  
    Dim i = 0
    For Each kv In recordTypes.Serializers
        Dim serValueType = CSharpTypeName(kv.Key.FullName)
        Dim serTypeName = CSharpTypeName(kv.Value)
        Dim serName = "_ser" & i
        #> 
        <#@ include file="ValueSerializer.tt" #>
        <#
        i += 1
    Next
    #> 

    namespace CodeGeneration {
        partial class RecordTypes {
            [GeneratedCode("", "")]
            static partial void GetGeneratedCodeHash(ref int hash) =>
                hash = <#= recordTypes.Hash #>;
        }
    }
}

<#
FormatCode()
#>

<#+
Function CSharpTypeName(typeName As String) As String
    Static codeDom = CodeDomProvider.CreateProvider("CSharp")
    Dim typeRef = New CodeTypeReference(typeName)
    Return codeDom.GetTypeOutput(typeRef)
End Function

Function CSharpTypeIdentifier(typeName As String) As String
    Return CSharpTypeName(typeName).
        Replace(".", "_").
        Replace("<", "_").
        Replace(",", "_").
        Replace(">", "_").
        Replace(" ", "")  
End Function

Dim valueSerializers = New Dictionary(Of String, String)
Function SerializerFor(prop As RecordProperty) As String
    Dim name = "_" + CSharpTypeIdentifier(prop.TypeName)
    valueSerializers(name) = prop.TypeName
    Return "ValueSerializers." + name
End Function

Sub FormatCode()
    Dim tree = CSharpSyntaxTree.ParseText(GenerationEnvironment.ToString())
    Dim root = tree.GetRoot()

    'Dim workspace = New AdhocWorkspace()
    'Dim options = workspace.GetOptions().
    '    WithChangedOption(CSharpFormattingOptions.OpenBracesInNewLineForMethods, false).
    '    WithChangedOption(CSharpFormattingOptions.OpenBracesInNewLineForTypes, false)
    'root = Formatter.Format(root, Formatter.Annotation, workspace, options)

    GenerationEnvironment.Clear()
    GenerationEnvironment.Append(root.NormalizeWhitespace().ToFullString())
End Sub
#>
